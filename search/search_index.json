{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"addict-tracking-changes Introduction Originally, this repository was a fork of https://github.com/mewwts/addict by Mats Julian Olsen. Overtime, it has substatially diverged in functionality and codebase that it seemed to make sense to breakout as its own repository. The original addict: provides an alternative and succient interface to manipulate a dictionary. This is especially useful when dealing with heavily nested dictionaries. As example (taken from https://github.com/mewwts/addict) a dictionary created using standard python dictionary interface looks as follows: body = { 'query': { 'filtered': { 'query': { 'match': {'description': 'addictive'} }, 'filter': { 'term': {'created_by': 'Mats'} } } } }` can be summarized to following three lines: body = Dict() body.query.filtered.query.match.description = 'addictive' body.query.filtered.filter.term.created_by = 'Mats' This repo builds on original addict and adds contraptions to track key additions in the dictionary. This features comes in quite handy in building reactive webapps where one has to respond to all the changes made on the browser. Addict-tracking-changes is the underpinning data-structure in https://github.com/Monallabs-org/addict-tracking-changes : a python based webframework build from https://github.com/justpy-org/justpy The functions relevant to tracking changed history are: get_changed_history and clear_changed_history . The get_changed_history returns an iterator of XPath style paths like /a/b/c/e (see Demo example ). Usage and examples Installation This project is not on PyPI. Its a simple package with no third party dependency. Simply clone from github and include the source directory in your PYTHONPATH. Demo example from addict import Dict body = Dict() body.query.filtered.query.match.description = 'addictive' body.query.filtered.filter.term.created_by = 'Mats' for changed_path in body.get_changed_history(): <work with changed_path body.clear_changed_history() when values are instances of container types addict works as expected when the values of keys are simple data types (such as string, int, float, etc.). However, for container types such as dict, list, tuples, etc. the behaviour is somewhat differs. dicts are treated as opaque object just like simple data types from addict import Dict mydict = Dict() mydict.a.b.c = {'kk': 1} mydict.a.b.e = {'dd': 1} for _ in mydict.get_changed_history(): print(_) will print /a/b/c /a/b/e and not /a/b/cc/kk /a/b/e/dd lists are seen as container, i.e., get_changed_history will report path for each element of the list from addict import Dict mydict = Dict() mydict.a.b = [1, [1]] mydict.a.c = [2, [2, [3]]] get_changed_history will report following paths: \"/a/b/0\", \"/a/b/1/0\", \"/a/c/0\", \"/a/c/1/0\", \"/a/c/1/1/0\", tuple tuple behave same as dict sets sets behave same as dict Known bugs and Caveats Only tracks field additions. Deletions and updates are not tracked. freeze doesn't guards against deletions building dict from another dict as shown in following expression wont' work cjs_cfg = Dict(x, track_changes=True) instead use cjs_cfg = Dict(track_changes = True) with open(\"cjs_cfg.pickle\", \"rb\") as fh: x = pickle.load(fh) for _ in oj.dictWalker(x): oj.dnew(cjs_cfg, _[0], _[1])","title":"Introduction"},{"location":"#addict-tracking-changes","text":"","title":"addict-tracking-changes"},{"location":"#introduction","text":"Originally, this repository was a fork of https://github.com/mewwts/addict by Mats Julian Olsen. Overtime, it has substatially diverged in functionality and codebase that it seemed to make sense to breakout as its own repository. The original addict: provides an alternative and succient interface to manipulate a dictionary. This is especially useful when dealing with heavily nested dictionaries. As example (taken from https://github.com/mewwts/addict) a dictionary created using standard python dictionary interface looks as follows: body = { 'query': { 'filtered': { 'query': { 'match': {'description': 'addictive'} }, 'filter': { 'term': {'created_by': 'Mats'} } } } }` can be summarized to following three lines: body = Dict() body.query.filtered.query.match.description = 'addictive' body.query.filtered.filter.term.created_by = 'Mats' This repo builds on original addict and adds contraptions to track key additions in the dictionary. This features comes in quite handy in building reactive webapps where one has to respond to all the changes made on the browser. Addict-tracking-changes is the underpinning data-structure in https://github.com/Monallabs-org/addict-tracking-changes : a python based webframework build from https://github.com/justpy-org/justpy The functions relevant to tracking changed history are: get_changed_history and clear_changed_history . The get_changed_history returns an iterator of XPath style paths like /a/b/c/e (see Demo example ).","title":"Introduction"},{"location":"#usage-and-examples","text":"","title":"Usage and examples"},{"location":"#installation","text":"This project is not on PyPI. Its a simple package with no third party dependency. Simply clone from github and include the source directory in your PYTHONPATH.","title":"Installation"},{"location":"#demo-example","text":"from addict import Dict body = Dict() body.query.filtered.query.match.description = 'addictive' body.query.filtered.filter.term.created_by = 'Mats' for changed_path in body.get_changed_history(): <work with changed_path body.clear_changed_history()","title":"Demo example"},{"location":"#when-values-are-instances-of-container-types","text":"addict works as expected when the values of keys are simple data types (such as string, int, float, etc.). However, for container types such as dict, list, tuples, etc. the behaviour is somewhat differs. dicts are treated as opaque object just like simple data types from addict import Dict mydict = Dict() mydict.a.b.c = {'kk': 1} mydict.a.b.e = {'dd': 1} for _ in mydict.get_changed_history(): print(_) will print /a/b/c /a/b/e and not /a/b/cc/kk /a/b/e/dd lists are seen as container, i.e., get_changed_history will report path for each element of the list from addict import Dict mydict = Dict() mydict.a.b = [1, [1]] mydict.a.c = [2, [2, [3]]] get_changed_history will report following paths: \"/a/b/0\", \"/a/b/1/0\", \"/a/c/0\", \"/a/c/1/0\", \"/a/c/1/1/0\", tuple tuple behave same as dict sets sets behave same as dict","title":"when values are instances of container types"},{"location":"#known-bugs-and-caveats","text":"Only tracks field additions. Deletions and updates are not tracked. freeze doesn't guards against deletions building dict from another dict as shown in following expression wont' work cjs_cfg = Dict(x, track_changes=True) instead use cjs_cfg = Dict(track_changes = True) with open(\"cjs_cfg.pickle\", \"rb\") as fh: x = pickle.load(fh) for _ in oj.dictWalker(x): oj.dnew(cjs_cfg, _[0], _[1])","title":"Known bugs and Caveats"},{"location":"main_doc/","text":"Usage Get and clear history mydict = Dict() mydict.a.b.c = 15 for _ in mydict.get_changed_history(): print(_) The output /a/b/c Use clear_changed_history method to clear all changed history. mydict.clear_changed_history() for _ in mydict.get_changed_history(): print(_) outputs empty. Freeze/unfreeze Once a dict is frozen, adding new keys will raise KeyError. Although modification to existing keys is allowed To freeze: mydict.freeze() To unfreeze: mydict.unfreeze() pickling History is lost during pickling dump and load operation. To enable tracking after pickle.load, use set_tracker operation. Handling dict and list as values of keys A py-dict is treated as any other opaque value object. Hence, mydict = Dict() mydict.a.b.c = {'kk': 1} mydict.a.b.e = {'dd': 1} for _ in mydict.get_changed_history(): print(_) will print paths /a/b/c /a/b/e and not /a/b/cc/kk /a/b/e/dd List values on the other hand are exposed. Addict will walk within the list recursively, an report all the list location. So, for following Dict with list values: trackerprop.a.b = [1, [1]] trackerprop.a.c = [2, [2, [3]]] get_changed_history will report following paths: \"/a/b/0\", \"/a/b/1/0\", \"/a/c/0\", \"/a/c/1/0\", \"/a/c/1/1/0\",","title":"Main doc"},{"location":"main_doc/#usage","text":"","title":"Usage"},{"location":"main_doc/#get-and-clear-history","text":"mydict = Dict() mydict.a.b.c = 15 for _ in mydict.get_changed_history(): print(_) The output /a/b/c Use clear_changed_history method to clear all changed history. mydict.clear_changed_history() for _ in mydict.get_changed_history(): print(_) outputs empty.","title":"Get and clear history"},{"location":"main_doc/#freezeunfreeze","text":"Once a dict is frozen, adding new keys will raise KeyError. Although modification to existing keys is allowed To freeze: mydict.freeze() To unfreeze: mydict.unfreeze()","title":"Freeze/unfreeze"},{"location":"main_doc/#pickling","text":"History is lost during pickling dump and load operation. To enable tracking after pickle.load, use set_tracker operation.","title":"pickling"},{"location":"main_doc/#handling-dict-and-list-as-values-of-keys","text":"A py-dict is treated as any other opaque value object. Hence, mydict = Dict() mydict.a.b.c = {'kk': 1} mydict.a.b.e = {'dd': 1} for _ in mydict.get_changed_history(): print(_) will print paths /a/b/c /a/b/e and not /a/b/cc/kk /a/b/e/dd List values on the other hand are exposed. Addict will walk within the list recursively, an report all the list location. So, for following Dict with list values: trackerprop.a.b = [1, [1]] trackerprop.a.c = [2, [2, [3]]] get_changed_history will report following paths: \"/a/b/0\", \"/a/b/1/0\", \"/a/c/0\", \"/a/c/1/0\", \"/a/c/1/1/0\",","title":"Handling dict and list as values of keys"}]}